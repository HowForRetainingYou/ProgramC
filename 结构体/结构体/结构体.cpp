#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//匿名结构体只能用一次;也不能实现结构体自引用


//typedef struct book
//{
//	char name[20];
//	double prize;
//	char id[20];
//}book;
//
//int main()
//{
//	struct book a = { "影响力",12.2,"10021" };
//	printf("%s %f %s", a.name, a.prize, a.id);
//}



//结构的自引用
//链表
//结构体每个节点最好存有数据和下个节点的地址
//struct A
//{
//	int x;
//	struct next  *next;
//};
//
//int main()
//{
//	;
//}

//数据结构：其实是数据在内存中的存储和组织的结构

//结构体内存对齐
/* 对齐规则:

1. 结构体的第⼀个成员对⻬到和结构体变量起始位置偏移量为0的地址处
2. 其他成员变量要对⻬到某个数字（对⻬数）的整数倍的地址处。
-对⻬数 = 编译器默认的⼀个对⻬数 与 该成员变量⼤⼩的较⼩值。
- Linux中 gcc 没有默认对⻬数，对⻬数就是成员⾃⾝的⼤⼩
3. 结构体总⼤⼩为最⼤对⻬数（结构体中每个成员变量都有⼀个对⻬数，所有对⻬数中最⼤的）的
整数倍。
4. 如果嵌套了结构体的情况，嵌套的结构体成员对⻬到⾃⼰的成员中最⼤对⻬数的整数倍处，结构
体的整体⼤⼩就是所有最⼤对⻬数（含嵌套结构体中成员的对⻬数）的整数倍。

*/
//
//struct A
//{
//	char a;
//	int b;
//	char c;
//};
//struct B
//{
//	char c;
//	char d;	
//	int a;
//};
//struct C
//{
//	double a;
//	char b;
//	int c;
//};
//int main()
//{
//	struct A a = { 0 };
//	struct B b = { 0 };
//	struct C c = { 0 };
//	printf("%zd\n", sizeof(a));
//	printf("%zd\n", sizeof(b));
//	printf("%zd\n", sizeof(c));
//	printf("%zd\n", sizeof(double));
//	return 0;
//}


/* 为什么存在内存对⻬?

⼤部分的参考资料都是这样说的：
1. 平台原因 (移植原因)：
不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定
类型的数据，否则抛出硬件异常。
2. 性能原因：
数据结构(尤其是栈)应该尽可能地在⾃然边界上对⻬。原因在于，为了访问未对⻬的内存，处理器需要
作两次内存访问；⽽对⻬的内存访问仅需要⼀次访问。假设⼀个处理器总是从内存中取8个字节，则地
址必须是8的倍数。如果我们能保证将所有的double类型的数据的地址都对⻬成8的倍数，那么就可以
⽤⼀个内存操作来读或者写值了。否则，我们可能需要执⾏两次内存访问，因为对象可能被分放在两
个8字节内存块中。
总体来说：结构体的内存对⻬是拿空间来换取时间的做法。

那在设计结构体的时候，我们既要满⾜对⻬，⼜要节省空间，如何做到：
让占⽤空间⼩的成员尽量集中在⼀起

*/

//#pragma 这个预处理指令，可以改变编译器的默认对⻬数。使用格式:#pragma pack(x),x是想要设置的对齐数


/*结构体传参*/
//struct D 
//{
//	int arr[500];
//};
//
//struct D a{{1,2,3} };////创建D型结构体变量a
//
//void print(struct D a)
//{
//	printf("%d\n", a.arr[1]);
//}
//
//struct D b{{1,2,3,4,5,6,7,8,9,10} };////创建D型结构体变量b
//
//void print(struct D* b)
//{
//	for (int i = 0; i < 10; i++)
//	{
//		printf("%d ", b->arr[i]);
//	}
//}
//int main()
//{
//	print(a);
//	print(&b);////传地址的方式相比开创另一份内存空间会节省太多内存，传a的话会额外创建500个int大小的空间
//}


//位段式结构
/*
位段的声明和结构是类似的，有两个不同：
1. 位段的成员必须是 int、unsigned int 或signed int ，在C99中位段成员的类型也可以
选择其他类型。
2. 位段的成员名后边有⼀个冒号和⼀个数字。
⽐如：

struct A
{
 int _a:2;//限定占用2个比特位
 int _b:5;//限定占用5个比特位
 int _c:10;//限定占用10个比特位
 int _d:30;//限定占用30个比特位，超出则会产生截断
};
printf("%d\n", sizeof(struct A));

A就是⼀个位段类型。
*/
/* 位段的内存分配
1. 位段的成员可以是 int unsigned int signed int 或者是 char 等类型
2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的⽅式来开辟的。
3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使⽤位段。
//⼀个例⼦

struct S
{
 char a:3;
 char b:4;
 char c:5;
 char d:4;
};
struct S s = {0};
s.a = 10;
s.b = 12;
s.c = 3;
s.d = 4;

*/